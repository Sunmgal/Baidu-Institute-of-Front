## 作用域原理 ##

> JavaScript中的函数运行在它们被**定义**的作用域里,而不是它们被**执行**的作用域里. —— 《JS权威指南》

- 全局作用域和局部作用域

> 1.全局作用域
> 
> 在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：
> 
> （1）最外层函数和在最外层函数外面定义的变量拥有全局作用域
> 
> （2）所有末定义直接赋值的变量自动声明为拥有全局作用域
>
    function doSomething(){
     var authorName="山边小溪";
     blogName="梦想天空";
     alert(authorName);
    }
    doSomething(); //山边小溪
    alert(blogName); //梦想天空
    alert(authorName); //脚本错误
    
>（3）所有window对象的属性拥有全局作用域
>
>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。



> 2.局部作用域
> 
> 和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域
 

----------

- **作用域链 scope chain**

原理

函数对象的一个内部属性：[[scope]]

> 1.函数对象的一个内部属性：[[scope]]

[[scope]]包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问 
<br/>
函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性.
<br/><br/>


>2.在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量

>

	function add(num1,num2) {
	    var sum = num1 + num2;
	    return sum;
	}
 
![](http://pic002.cnblogs.com/images/2011/36987/2011090414435366.jpg)


>3.函数执行时 

函数add的作用域将会在执行时用到
>
	var total = add(5,10);	

　　执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。

　　这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示： 

![](http://pic002.cnblogs.com/images/2011/36987/2011090414444843.jpg)


　　在函数执行过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。


因为函数对象的[[scope]]属性是在定义一个函数的时候决定的, 而非调用的时候
>    
	<script>
	     var name = 'laruence';  //全局
	     function echo() {       //全局
	          alert(name);
	     }
	     function env() {        //全局
	          var name = 'eve';  //局部
	          echo();			 
	     }
	     env();//laruence			
	 </script>

>
	<script>
		function factory() {			///
		     var name = 'laruence';     //定义name
		     var intro = function(){    //找不到name的定义，向外找找到name=laruence
		          alert('I am ' + name);
		     }
		     return intro;              //返回I am laruence  
		}
		function app(para){			    //para = eve 	
		     var name = para;		    //局部变量name = eve
		     var func = factory();	    		
		     func();					//I am laruence.
		}
		app('eve');
	</script>





例子
>
    var name = 'laruence';
    function echo() {
	    alert(name);	 	//undefine
	    var name = 'eve';   
	    alert(name);		//eve
	    alert(age);			//age is not define
    }    
    echo();  //undefine  原因：声明提前

>	等于
>	
    var name = 'laruence';
    function echo() {
		var	name；
	    alert(name);    //undefine
	    name = 'eve';   
	    alert(name);	//eve
	    alert(age);		//age is not define
    }     
    echo();   


>    
>     var func = function(lps, rps){
          var name = 'laruence';
          ........
     }
     func();




 


## 预编译 ##

> 

- 定义

> JS在执行每一段JS代码之前, 都会首先处理var关键字和function定义式(函数定义式和函数表达式).
> 

 解释：在调用函数执行之前, 会首先创建一个活动对象, 然后搜寻这个函数中的局部变量定义,和函数定义, 将变量名和函数名都做为这个活动对象的同名属性, 对于局部变量定义,变量的值会在真正执行的时候才计算, 此时只是简单的赋为undefined.



- JS的预编译是以段为处理单元
> 
	<script>
	     alert(typeof eve); //结果:undefined
	</script>
	<script>
	     function eve() {
	          alert('I am Laruence');
	     }
	</script>


- 函数定义式和函数表达式在预编译中的不同
>
	<script>
		alert(typeof eve); //结果:function
		alert(typeof walle); //结果:undefined
		function eve() { //函数定义式
		  alert('I am Laruence');
		};
		var walle = function() { //函数表达式
		}
		alert(typeof walle); //结果:function
	</script>

> 函数定义式, 会将函数定义提前. 而函数表达式, 会在执行过程中才计算.


- 
